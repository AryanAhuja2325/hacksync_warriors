from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Dict, Any, List, Optional
import logging
import asyncio
from concurrent.futures import ThreadPoolExecutor
import traceback
from agents.copywriting import generate_copy
from influencer_discovery import discover_influencers, generate_outreach_message
from agents.youtube_discovery import discover_youtube_influencers
from agents.market_change import find_influencers
from agents.outreach import generate_outreach_for_influencer
from agents.content_fetchers import fetch_youtube_content
from agents.content_normalizer import normalize_content_list
from agents.content_summarizer import summarize_content
from agents.visualAgent import VisualAgent
from agents.mediaAgent import generate_media_plan

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(
    title="Marketing Campaign Orchestrator",
    description="Orchestrates multiple marketing agents to generate complete campaigns",
    version="1.0.0"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allow all origins (for development)
    allow_credentials=True,
    allow_methods=["*"],  # Allow all methods
    allow_headers=["*"],  # Allow all headers
)


# Models
class CampaignRequest(BaseModel):
    strategy: Dict[str, Any]
    
    class Config:
        json_schema_extra = {
            "example": {
                "strategy": {
                    "product": "EcoBottle - Reusable Water Bottle",
                    "audience": "environmentally conscious millennials",
                    "goal": "increase brand awareness",
                    "tone": "friendly and inspiring",
                    "platforms": ["Instagram", "Facebook", "Blog"],
                    "stylistics": "focus on sustainability"
                }
            }
        }


class CampaignResponse(BaseModel):
    status: str
    strategy: Dict[str, Any]
    copywriting: Optional[Dict[str, Any]] = None
    influencers: Optional[Dict[str, Any]] = None
    mood_board: Optional[Dict[str, Any]] = None
    media_plan: Optional[Dict[str, Any]] = None
    outreach_messages: Optional[List[Dict[str, Any]]] = None
    errors: Optional[Dict[str, str]] = None
    execution_time: Optional[float] = None


class AIDiscoveryRequest(BaseModel):
    strategy: Dict[str, Any]
    
    class Config:
        json_schema_extra = {
            "example": {
                "strategy": {
                    "product": "EcoBottle - Reusable Water Bottle",
                    "audience": "environmentally conscious college students",
                    "platforms": ["Instagram", "YouTube"],
                    "stylistics": "sustainability",
                    "location": "India"
                }
            }
        }


class AIDiscoveryResponse(BaseModel):
    status: str
    count: int
    influencers: List[Dict[str, Any]]
    disclaimer: str
    metadata: Dict[str, Any]


class OutreachRequest(BaseModel):
    influencer: Dict[str, Any]
    campaign_details: Dict[str, Any]
    
    class Config:
        json_schema_extra = {
            "example": {
                "influencer": {
                    "name": "FitWithRhea",
                    "platform": "Instagram",
                    "niche": "Fitness",
                    "followers": "120k",
                    "reason": "Creates college-focused fitness content"
                },
                "campaign_details": {
                    "product": "EcoBottle",
                    "tone": "friendly and inspiring"
                }
            }
        }


class YouTubeDiscoveryRequest(BaseModel):
    domain: str
    audience: str = ""
    country: str = "IN"
    min_followers: int = 10000
    max_followers: int = 500000
    max_results: int = 8
    
    class Config:
        json_schema_extra = {
            "example": {
                "domain": "sustainable fashion",
                "audience": "college students",
                "country": "IN",
                "min_followers": 10000,
                "max_followers": 500000,
                "max_results": 8
            }
        }


class YouTubeDiscoveryResponse(BaseModel):
    status: str
    count: int
    discovery_method: str
    verification_notice: str
    influencers: List[Dict[str, Any]]


class MarketDiscoveryRequest(BaseModel):
    domain: str
    target_audience: str
    platforms: List[str] = ["Instagram", "YouTube"]
    country: str = "IN"
    max_results: int = 10
    
    class Config:
        json_schema_extra = {
            "example": {
                "domain": "sustainable fashion",
                "target_audience": "young women aged 18-30",
                "platforms": ["Instagram", "YouTube"],
                "country": "IN",
                "max_results": 10
            }
        }


class MarketDiscoveryResponse(BaseModel):
    status: str
    count: int
    discovery_method: str
    verification_notice: str
    influencers: List[Dict[str, Any]]


class ContentAwareOutreachRequest(BaseModel):
    influencer: Dict[str, Any]
    brand_name: str
    product_domain: str
    target_audience: str
    message_type: str = "initial_contact"
    collaboration_idea: Optional[str] = None
    analyze_content: bool = False
    
    class Config:
        json_schema_extra = {
            "example": {
                "influencer": {
                    "name": "Tech Creator",
                    "platform": "YouTube",
                    "url": "https://youtube.com/@creator",
                    "niche": "tech reviews"
                },
                "brand_name": "TechGear Pro",
                "product_domain": "tech accessories",
                "target_audience": "tech enthusiasts",
                "message_type": "casual_dm",
                "collaboration_idea": "Product review collaboration",
                "analyze_content": True
            }
        }


class ContentAwareOutreachResponse(BaseModel):
    status: str
    influencer_name: str
    outreach: Dict[str, str]
    content_analysis: Optional[Dict[str, Any]] = None


class VisualMoodBoardRequest(BaseModel):
    strategy: Dict[str, Any]
    num_variations: int = 4
    reference_image_path: Optional[str] = None
    
    class Config:
        json_schema_extra = {
            "example": {
                "strategy": {
                    "product": "EcoBottle - Sustainable Water Bottle",
                    "audience": "environmentally conscious college students",
                    "tone": "friendly and inspiring",
                    "stylistics": "sustainability and eco-friendly lifestyle"
                },
                "num_variations": 4,
                "reference_image_path": "path/to/reference.jpg"
            }
        }


class VisualMoodBoardResponse(BaseModel):
    status: str
    product: str
    audience: str
    visual_theme: str
    color_palette: List[str]
    tiles: List[Dict[str, Any]]
    total_generated: int
    json_file: str


class MediaPlanRequest(BaseModel):
    domain: str
    target_audience: str
    competitors: List[str] = []
    
    class Config:
        json_schema_extra = {
            "example": {
                "domain": "sustainable fashion",
                "target_audience": "environmentally conscious college students",
                "competitors": ["Everlane", "Patagonia", "Reformation"]
            }
        }


class MediaPlanResponse(BaseModel):
    status: str
    recommended_platforms: List[Dict[str, Any]]
    best_posting_times: Dict[str, Any]
    content_types: List[str]
    growth_strategies: List[str]
    mistakes_to_avoid: List[str]
    competitor_insights: Dict[str, Any]
    metadata: Dict[str, Any]


# Routes
@app.get("/")
async def root():
    return {
        "status": "healthy",
        "service": "Marketing Campaign Orchestrator",
        "version": "2.0.0",
        "available_agents": [
            "copywriting",
            "ai_influencer_discovery",
            "youtube_discovery",
            "market_discovery",
            "content_aware_outreach",
            "visual_mood_board",
            "media_planning"
        ]
    }


@app.post("/generate-campaign", response_model=CampaignResponse)
async def generate_campaign(request: CampaignRequest):
    """
    üöÄ UNIFIED CAMPAIGN ORCHESTRATOR
    
    Runs ALL marketing agents in parallel and returns a complete campaign package:
    - Copywriting (captions, ads, blog ideas)
    - Influencer Discovery (market research)
    - Visual Mood Board (AI-generated images)
    - Media Planning (platform strategy)
    - Outreach Messages (personalized influencer outreach)
    
    All agents run concurrently for maximum performance.
    Errors in individual agents don't block the entire campaign.
    """
    import time
    start_time = time.time()
    
    strategy = request.strategy
    errors = {}
    
    # Thread pool for CPU-bound tasks
    executor = ThreadPoolExecutor(max_workers=5)
    loop = asyncio.get_event_loop()
    
    logger.info(f"üöÄ Starting unified campaign generation for: {strategy.get('product', 'Unknown')}")
    
    # Define async wrappers for each agent
    async def run_copywriting():
        try:
            logger.info("üìù Running copywriting agent...")
            result = await loop.run_in_executor(executor, generate_copy, strategy)
            logger.info("‚úÖ Copywriting complete")
            return result
        except Exception as e:
            logger.error(f"‚ùå Copywriting failed: {str(e)}")
            errors['copywriting'] = str(e)
            return None
    
    async def run_influencer_discovery():
        try:
            logger.info("üîç Running influencer discovery...")
            domain = strategy.get('stylistics', strategy.get('product', ''))
            audience = strategy.get('audience', '')
            platforms = strategy.get('platforms', ['Instagram', 'YouTube'])
            country = strategy.get('location', 'IN')
            
            result = await loop.run_in_executor(
                executor,
                find_influencers,
                domain,
                audience,
                5,  # num_results
                True,  # profiles_only
                country,
                None,  # recent_days
                platforms
            )
            logger.info(f"‚úÖ Found {len(result.get('influencers', []))} influencers")
            return result
        except Exception as e:
            logger.error(f"‚ùå Influencer discovery failed: {str(e)}")
            errors['influencer_discovery'] = str(e)
            return None
    
    async def run_mood_board():
        try:
            logger.info("üé® Running visual mood board agent...")
            agent = VisualAgent()
            result = await loop.run_in_executor(
                executor,
                agent.generate_mood_board,
                strategy,
                4  # num_variations
            )
            logger.info(f"‚úÖ Generated {result.get('total_generated', 0)} mood board tiles")
            return result
        except Exception as e:
            logger.error(f"‚ùå Mood board failed: {str(e)}")
            errors['mood_board'] = str(e)
            return None
    
    async def run_media_plan():
        try:
            logger.info("üìä Running media planning agent...")
            domain = strategy.get('stylistics', strategy.get('product', ''))
            audience = strategy.get('audience', '')
            competitors = strategy.get('competitors', [])
            
            result = await loop.run_in_executor(
                executor,
                generate_media_plan,
                domain,
                audience,
                competitors
            )
            logger.info("‚úÖ Media plan complete")
            return result
        except Exception as e:
            logger.error(f"‚ùå Media planning failed: {str(e)}")
            errors['media_plan'] = str(e)
            return None
    
    async def run_outreach_generation(influencers_data):
        try:
            if not influencers_data or not influencers_data.get('influencers'):
                return None
            
            logger.info("‚úâÔ∏è Generating outreach messages...")
            brand_name = strategy.get('product', '').split(' - ')[0].split(':')[0].strip()
            product_domain = strategy.get('stylistics', strategy.get('product', ''))
            audience = strategy.get('audience', '')
            
            outreach_tasks = []
            for influencer in influencers_data['influencers'][:3]:  # Top 3 influencers
                task = loop.run_in_executor(
                    executor,
                    generate_outreach_for_influencer,
                    influencer,
                    brand_name,
                    product_domain,
                    audience,
                    "initial_contact",
                    None,  # collaboration_idea
                    None   # content_summary
                )
                outreach_tasks.append(task)
            
            outreach_results = await asyncio.gather(*outreach_tasks, return_exceptions=True)
            
            # Combine influencer data with outreach
            messages = []
            for i, result in enumerate(outreach_results):
                if not isinstance(result, Exception):
                    messages.append({
                        "influencer": influencers_data['influencers'][i],
                        "outreach": result
                    })
            
            logger.info(f"‚úÖ Generated {len(messages)} outreach messages")
            return messages
        except Exception as e:
            logger.error(f"‚ùå Outreach generation failed: {str(e)}")
            errors['outreach'] = str(e)
            return None
    
    try:
        # Step 1: Run independent agents in parallel
        logger.info("‚ö° Running all agents in parallel...")
        
        copywriting_task = run_copywriting()
        influencer_task = run_influencer_discovery()
        mood_board_task = run_mood_board()
        media_plan_task = run_media_plan()
        
        # Gather results (continue even if some fail)
        copywriting, influencers, mood_board, media_plan = await asyncio.gather(
            copywriting_task,
            influencer_task,
            mood_board_task,
            media_plan_task,
            return_exceptions=True
        )
        
        # Handle exceptions from gather
        if isinstance(copywriting, Exception):
            errors['copywriting'] = str(copywriting)
            copywriting = None
        if isinstance(influencers, Exception):
            errors['influencer_discovery'] = str(influencers)
            influencers = None
        if isinstance(mood_board, Exception):
            errors['mood_board'] = str(mood_board)
            mood_board = None
        if isinstance(media_plan, Exception):
            errors['media_plan'] = str(media_plan)
            media_plan = None
        
        # Step 2: Generate outreach (depends on influencers)
        outreach_messages = await run_outreach_generation(influencers)
        
        execution_time = time.time() - start_time
        
        logger.info(f"üéâ Campaign generation complete in {execution_time:.2f}s")
        
        # Build response
        response = CampaignResponse(
            status="success" if (copywriting or influencers or mood_board or media_plan) else "partial_failure",
            strategy=strategy,
            copywriting=copywriting,
            influencers=influencers,
            mood_board=mood_board,
            media_plan=media_plan,
            outreach_messages=outreach_messages,
            errors=errors if errors else None,
            execution_time=round(execution_time, 2)
        )
        
        return response
        
    except Exception as e:
        logger.error(f"‚ùå Campaign orchestration failed: {str(e)}")
        logger.error(traceback.format_exc())
        raise HTTPException(
            status_code=500,
            detail=f"Campaign generation failed: {str(e)}"
        )
    finally:
        executor.shutdown(wait=False)


@app.post("/generate-copy")
async def generate_copy_only(request: CampaignRequest):
    """
    Generate only copywriting content (bypass orchestrator)
    """
    try:
        logger.info("Generating copy only...")
        result = generate_copy(request.strategy)
        return {"status": "success", "data": result}
    except Exception as e:
        logger.error(f"Copywriting error: {e}")
        raise HTTPException(status_code=500, detail=f"Copywriting failed: {str(e)}")


@app.post("/ai-discover-influencers", response_model=AIDiscoveryResponse)
async def ai_discover_influencers(request: AIDiscoveryRequest):
    """
    AI-powered influencer discovery based on campaign strategy
    
    Uses LLM to suggest relevant micro/nano influencers with justification.
    Results are AI-generated suggestions that should be verified before outreach.
    """
    try:
        logger.info(f"AI discovering influencers for product: {request.strategy.get('product', 'Unknown')}")
        
        result = discover_influencers(request.strategy)
        
        logger.info(f"AI suggested {result['count']} influencers")
        
        return AIDiscoveryResponse(
            status="success",
            count=result['count'],
            influencers=result['influencers'],
            disclaimer=result['disclaimer'],
            metadata=result['metadata']
        )
        
    except ValueError as e:
        logger.error(f"Configuration error: {e}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"AI discovery error: {e}")
        raise HTTPException(status_code=500, detail=f"AI discovery failed: {str(e)}")


@app.post("/generate-outreach")
async def generate_outreach(request: OutreachRequest):
    """
    Generate personalized outreach message for an influencer
    
    Creates authentic, context-aware collaboration proposals.
    """
    try:
        logger.info(f"Generating outreach for {request.influencer.get('name', 'Unknown')}")
        
        message = generate_outreach_message(
            influencer=request.influencer,
            campaign_details=request.campaign_details
        )
        
        return {
            "status": "success",
            "influencer": request.influencer['name'],
            "message": message
        }
        
    except ValueError as e:
        logger.error(f"Configuration error: {e}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Outreach generation error: {e}")
        raise HTTPException(status_code=500, detail=f"Outreach generation failed: {str(e)}")


@app.post("/discover-youtube-influencers", response_model=YouTubeDiscoveryResponse)
async def discover_youtube_influencers_endpoint(request: YouTubeDiscoveryRequest):
    """
    Discover real YouTube influencers using YouTube Data API v3
    
    Returns verified creators with real subscriber counts, filtered by niche and region.
    Data sourced directly from YouTube - real channels with verified metrics.
    
    ‚ö†Ô∏è Please verify profiles and content alignment before outreach.
    """
    try:
        logger.info(f"Discovering YouTube influencers: {request.domain} for {request.audience} in {request.country}")
        
        influencers = discover_youtube_influencers(
            domain=request.domain,
            audience=request.audience,
            country=request.country,
            min_followers=request.min_followers,
            max_followers=request.max_followers,
            max_results=request.max_results
        )
        
        logger.info(f"Found {len(influencers)} YouTube influencers")
        
        return YouTubeDiscoveryResponse(
            status="success",
            count=len(influencers),
            discovery_method="youtube_api_v3",
            verification_notice="‚ö†Ô∏è Please verify profiles and content alignment before outreach.",
            influencers=influencers
        )
        
    except ValueError as e:
        logger.error(f"Configuration error: {e}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"YouTube discovery error: {e}")
        raise HTTPException(status_code=500, detail=f"YouTube discovery failed: {str(e)}")


@app.post("/discover-market-influencers", response_model=MarketDiscoveryResponse)
async def discover_market_influencers(request: MarketDiscoveryRequest):
    """
    Discover real influencers using Google Custom Search API
    
    Returns verified profiles from Instagram/YouTube with relevance scoring.
    Uses domain-first queries to ensure relevant results.
    
    ‚ö†Ô∏è Please verify profiles and content alignment before outreach.
    """
    try:
        logger.info(f"Discovering market influencers: {request.domain} for {request.target_audience}")
        
        result = find_influencers(
            domain=request.domain,
            target_audience=request.target_audience,
            platforms=request.platforms,
            country=request.country,
            num_results=request.max_results
        )
        
        # Extract influencers list from result dict
        influencers = result.get("influencers", [])
        
        logger.info(f"Found {len(influencers)} market influencers")
        
        return MarketDiscoveryResponse(
            status="success",
            count=len(influencers),
            discovery_method="google_custom_search",
            verification_notice="‚ö†Ô∏è Verify profiles and content alignment before outreach. Relevance scores provided.",
            influencers=influencers
        )
        
    except ValueError as e:
        logger.error(f"Configuration error: {e}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Market discovery error: {e}")
        raise HTTPException(status_code=500, detail=f"Market discovery failed: {str(e)}")


@app.post("/generate-content-aware-outreach", response_model=ContentAwareOutreachResponse)
async def generate_content_aware_outreach(request: ContentAwareOutreachRequest):
    """
    Generate personalized outreach with optional content analysis
    
    If analyze_content=true and influencer is YouTube creator, fetches and analyzes
    their recent videos to create hyper-personalized outreach referencing actual content.
    
    Message types: casual_dm, initial_contact, follow_up, formal_email, partnership_proposal
    """
    try:
        influencer = request.influencer
        logger.info(f"Generating outreach for {influencer.get('name', 'Unknown')}")
        
        content_summary = None
        
        # Optional: Analyze content if requested and it's YouTube
        if request.analyze_content and influencer.get('platform') == 'YouTube':
            try:
                logger.info("Fetching and analyzing YouTube content...")
                
                # Fetch recent videos
                raw_content = fetch_youtube_content(
                    channel_url=influencer.get('url', ''),
                    max_videos=5
                )
                
                # Normalize content
                normalized_content = normalize_content_list(raw_content, "YouTube")
                
                # Summarize themes
                content_summary = summarize_content(normalized_content)
                
                logger.info("Content analysis complete")
                
            except Exception as e:
                logger.warning(f"Content analysis failed, falling back to basic outreach: {e}")
                content_summary = None
        
        # Generate outreach message
        outreach = generate_outreach_for_influencer(
            influencer=influencer,
            brand_name=request.brand_name,
            product_domain=request.product_domain,
            target_audience=request.target_audience,
            message_type=request.message_type,
            collaboration_idea=request.collaboration_idea,
            content_summary=content_summary
        )
        
        return ContentAwareOutreachResponse(
            status="success",
            influencer_name=influencer.get('name', 'Unknown'),
            outreach=outreach,
            content_analysis=content_summary if request.analyze_content else None
        )
        
    except ValueError as e:
        logger.error(f"Configuration error: {e}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Outreach generation error: {e}")
        raise HTTPException(status_code=500, detail=f"Outreach generation failed: {str(e)}")


@app.post("/generate-mood-board", response_model=VisualMoodBoardResponse)
async def generate_mood_board(request: VisualMoodBoardRequest):
    """
    Generate visual mood board with 4 images based on campaign strategy
    
    Generates product-specific images showing target audience using the product.
    Supports optional reference image for image-to-image generation.
    Returns JSON file with image URLs and base64 data.
    
    At least 1 image will depict the target audience using the product (lifestyle shot).
    """
    try:
        strategy = request.strategy
        logger.info(f"Generating mood board for product: {strategy.get('product', 'Unknown')}")
        
        # Initialize visual agent
        visual_agent = VisualAgent()
        
        # Generate mood board
        result = visual_agent.generate_mood_board(
            strategy=strategy,
            num_variations=request.num_variations,
            reference_image_path=request.reference_image_path
        )
        
        logger.info(f"Mood board generated: {result['total_generated']}/{result['requested']} tiles")
        
        # Get JSON filename (latest file in output directory)
        import os
        import glob
        json_files = glob.glob(os.path.join(visual_agent.output_dir, "mood_board_*.json"))
        latest_json = max(json_files, key=os.path.getctime) if json_files else "N/A"
        
        return VisualMoodBoardResponse(
            status=result['status'],
            product=result['product'],
            audience=result['audience'],
            visual_theme=result['visual_theme'],
            color_palette=result['color_palette'],
            tiles=result['tiles'],
            total_generated=result['total_generated'],
            json_file=latest_json
        )
        
    except ValueError as e:
        logger.error(f"Configuration error: {e}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Mood board generation error: {e}")
        raise HTTPException(status_code=500, detail=f"Mood board generation failed: {str(e)}")


@app.post("/generate-media-plan", response_model=MediaPlanResponse)
async def generate_media_plan_endpoint(request: MediaPlanRequest):
    """
    Generate media planning recommendations
    
    Returns platform recommendations, posting times, content strategies,
    and growth tactics based on domain, audience, and competitors.
    """
    try:
        logger.info(f"Generating media plan for domain: {request.domain}")
        
        result = generate_media_plan(
            domain=request.domain,
            target_audience=request.target_audience,
            competitors=request.competitors
        )
        
        logger.info(f"Media plan generated: {len(result['recommended_platforms'])} platforms recommended")
        
        return MediaPlanResponse(
            status="success",
            recommended_platforms=result['recommended_platforms'],
            best_posting_times=result['best_posting_times'],
            content_types=result['content_types'],
            growth_strategies=result['growth_strategies'],
            mistakes_to_avoid=result['mistakes_to_avoid'],
            competitor_insights=result['competitor_insights'],
            metadata=result['metadata']
        )
        
    except Exception as e:
        logger.error(f"Media planning error: {e}")
        raise HTTPException(status_code=500, detail=f"Media planning failed: {str(e)}")


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8001)
